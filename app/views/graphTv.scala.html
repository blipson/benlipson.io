<!DOCTYPE html>

<html lang="en">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <link rel="stylesheet" href="//cdn.jsdelivr.net/chartist.js/latest/chartist.min.css">
    <script src="//cdn.jsdelivr.net/chartist.js/latest/chartist.min.js"></script>
    <body>
        <h1>
            Graph TV
        </h1>
        <h4>
            Enter the name of a TV show to get metrics about it. It'll graph IMDB ratings over time, with different seasons in different colors. You can hover over the data points for additional info about each episode.
        </h4>
        <input id="graphtv-input" class="input" type="text" placeholder="TV Show" autofocus>
        <span id="loading" style="display: none">Loading...</span>
        <span id="not-found" style="display: none">TV show not found.</span>
        <h2 id="graphtv-header">
        </h2>
        <div id="charterino" style="height: 50vh" class="ct-chart ct-perfect-fourth"></div>
        <div id="tooltip" style="display: none; position: fixed; bottom: 550px; left: 50px;"></div>
        <span>Written in JavaScript
            <a href="https://github.com/blipson/benlipson.io/blob/master/app/views/graphTv.scala.html" target="_blank">Wanna see the code?</a>
        </span>
    </body>
    <script type="text/javascript">
        function makeGraph(seasons) {
            seasons.sort((a, b) => a.episodes[0].season - b.episodes[0].season);
            const maxSeason = seasons
                    .map(season => parseInt(season.episodes[0].seasonNumber))
                    .reduce((previousMax, curr) => Math.max(previousMax, curr), 0);
            const prependNulls = seasons.reduce((acc, season) => {
                const seasonNumber = parseInt(season.episodes[0].seasonNumber);
                if (seasonNumber === 1) {
                    acc[seasonNumber] = [];
                    acc[seasonNumber + 1] = [...Array(season.episodes.length).keys()].map(() => null);
                } else if (seasonNumber < maxSeason) {
                    acc[seasonNumber + 1] = [...Array(season.episodes.length + acc[seasonNumber].length).keys()].map(() => null);
                }
                return acc;
            }, {});

            const output = seasons.map((season) => {
                return [...prependNulls[season.episodes[0].seasonNumber], ...season.episodes.map(episode => {
                    return {
                        number: `Season ${episode.seasonNumber}, Episode ${episode.episodeNumber}`,
                        rating: episode.imDbRating,
                        released: episode.released,
                        title: episode.title,
                        value: episode.imDbRating
                    }
                })];
            });
            const lowest = seasons.map(season =>
                season.episodes.reduce((previousMinThisSeason, curr) => Math.min(previousMinThisSeason.imDbRating, curr.imDbRating), 0)
            ).reduce((previousMin, curr) => Math.min(previousMin, curr), 0);

            let chart = new Chartist.Line('.ct-chart', {
                series: output,
            }, {
                low: lowest
            });

            chart.on('draw', (data) => {
                if (data.type === 'point') {
                    data.element.attr({
                        title: data.series[data.index].title,
                        value: data.series[data.index].value,
                        number: data.series[data.index].number,
                        released: data.series[data.index].released,
                        rating: data.series[data.index].rating
                    });
                }
            });

            chart.on('created', () => {
                $('#loading').css('display', 'none');
                $('#graphtv-input').prop('disabled', false)
                $('#graphtv-header').text(seasons[0].title);
                const ctPoint = $('.ct-point');
                ctPoint.on('mouseover', function (e) {
                    const mouseX = e.pageX - 60;
                    const mouseY = e.pageY + 25;

                    $('#tooltip').css({ 'top': mouseY, 'left': mouseX, 'display': '' })
                            .html($(this).attr('title') + '<br/>'
                                    + $(this).attr('number') + '<br/>'
                                    + $(this).attr('released') + '<br/>'
                                    + 'IMDB Rating: ' + $(this).attr('rating'));
                });

                ctPoint.on('mouseout', function (e) {
                    $('#tooltip').css('display', 'none');
                });
            });
        }

        const searchShows = async (searchTerm) => {
            const searchResults = await fetch(`https://imdb-api.com/en/API/searchSeries/k_9fbi3vm5/${searchTerm}`).then(response => response.json());
            const matchingShow = searchResults.results.filter(show => show.title.toLowerCase() === searchTerm.toLowerCase());
            return matchingShow.length ? matchingShow[0] : {};
        }

        const getShowSeasonNumbers = async (id) => {
            const showDetailResults = await fetch(`https://imdb-api.com/en/API/Title/k_9fbi3vm5/${id}`).then(response => response.json());
            return showDetailResults.tvSeriesInfo.seasons;
        }

        const getShowSeasonDetails = async (id, seasonNumbers) => {
            return Promise.all(seasonNumbers.map(seasonNumber => {
                return fetch(`https://imdb-api.com/en/API/SeasonEpisodes/k_9fbi3vm5/${id}/${seasonNumber}`)
                        .then(response => response.json())
            }));
        }
        const graphTvInput = $('#graphtv-input');

        graphTvInput.on('keyup', async (e) => {
            if (e.keyCode === 13) {
                const loading = $('#loading');
                const notFound = $('#not-found');
                loading.css('display', '');
                notFound.css('display', 'none');
                graphTvInput.prop('disabled', true)
                const show = await searchShows($('#graphtv-input').val());
                if (!jQuery.isEmptyObject(show)) {
                    const seasonNumbers = await getShowSeasonNumbers(show.id);
                    getShowSeasonDetails(show.id, seasonNumbers).then(seasons => {
                        makeGraph(seasons);
                    });
                } else {
                    loading.css('display', 'none');
                    notFound.css('display', '');
                    graphTvInput.prop('disabled', false)
                }
            }
        });
    </script>
</html>
