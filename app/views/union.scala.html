<!DOCTYPE html>

<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="shortcut icon" href="#" />
        <title>Lipson</title>
    </head>
    <body>
        <h1>
            Using UNION to optimize SQL queries
        </h1>
        <p>&emsp;&emsp;I recently learned about this trick for optimizing certain SQL queries, so I thought I'd share it in a blog post.
            It applies specifically to any query in which you have to retrieve some data from a table via two different routes.
            What do I mean by routes? Well if we think of our database as a large graph, where the nodes are the tables and the
            edges are the foreign key relationships between them, then having a "route" to certain data is just a path between
            two nodes. So having two different routes to get at the data you want might look something like this:
        </p>
        <p>
            <img src="@controllers.routes.Assets.at("images/empty_graph.png")" width="250" alt="" />
        </p>
        <p>&emsp;&emsp;Normally this would be done using
            <code>JOIN</code> clauses. To imagine that let's create an example schema. Perhaps you work at a company which uses
            a SQL database to manage its orders. Whenever a customer places an order it gets recorded within a table called <code>order</code>
            . In addition to tracking orders, perhaps your company wants to track which customers placed which orders by name. So we have another
            table called <code>customer</code>. Let's say that a group of customers can all place a single order together, and that one customer
            can place many orders. As such, there must be a many-to-many relationship with a table between them, which we'll call
            <code>customer_order</code>.
        </p>
        <pre style="display: flex">
            <code>
                CREATE TABLE order(
                    order_id SERIAL PRIMARY KEY,
                );

                CREATE TABLE customer (
                    customer_id SERIAL PRIMARY KEY,
                    name VARCHAR
                );

                CREATE TABLE customer_order (
                    customer_id INTEGER NOT NULL,
                    order_id INTEGER NOT NULL,
                    CONSTRAINT fk_customer FOREIGN KEY(customer_id) REFERENCES customer(customer_id),
                    CONSTRAINT fk_order FOREIGN KEY(order_id) REFERENCES order(order_id)
                );
            </code>
            <img src="@controllers.routes.Assets.at("images/customer_to_order.png")" style="padding-left: 5%" alt="" />
        </pre>
        <p>&emsp;&emsp;Now let's say that you're designing a feature for your system in which you need to search for all the orders that a customer
            has placed, and that you need to be able to search by the customer's name. It's pretty easy to implement this.
        </p>
        <pre>
            <code>
                SELECT order_id
                FROM order
                JOIN customer_order ON order.order_id = customer_order.order_id
                JOIN customer ON customer_order.customer_id = customer.customer_id
                WHERE customer.name = ?;
            </code>
        </pre>
        <p>&emsp;&emsp;That's all well and good. But now let's imagine that you want to start grouping customers. Yes customers sometimes
            place orders on their own as an individual, but sometimes they do it on behalf of a company. It might be interesting to track
            which company a customer belongs to, if they belong to any at all. So you add another table called <code>company</code> with
            a one-to-many relationship with customers, assuming each customer can only belong to one company. But here's the kicker...
            let's say when someone places an order they can choose to either do it as an individual customer, or do it on behalf of
            a company. If they choose the latter, then they don't have to supply any of their own individual customer information
            because all of that information is already stored when the company "registered" in our system and assigned a few
            "point of contact" customers to themselves ahead of time. So now our orders can have This means that in order to continue accurately tracking which
            customers are associated with orders, we need to link the <code>company</code> and <code>order</code> tables. Like the
            relationship between customers and orders, this will also have a many-to-many relationship with an intermediary table called
            <code>company_order</code>. Let's see what our new schema looks like.</p>
        <pre style="display: flex">
            <code>
                CREATE TABLE order(
                    order_id SERIAL PRIMARY KEY,
                );

                CREATE TABLE company (
                    company_id SERIAL PRIMARY KEY,
                )

                CREATE TABLE customer (
                    customer_id SERIAL PRIMARY KEY
                    name VARCHAR,
                    company_id INTEGER,
                    CONSTRAINT fk_company FOREIGN KEY(company_id) REFERENCES company(company_id)
                );

                CREATE TABLE company_order (
                    company_id INTEGER NOT NULL,
                    order_id INTEGER NOT NULL,
                    CONSTRAINT fk_company FOREIGN KEY(company_id) REFERENCES customer(company_id),
                    CONSTRAINT fk_order FOREIGN KEY(order_id) REFERENCES order(order_id)
                );

                CREATE TABLE customer_order (
                    customer_id INTEGER NOT NULL,
                    order_id INTEGER NOT NULL,
                    CONSTRAINT fk_customer FOREIGN KEY(customer_id) REFERENCES customer(customer_id),
                    CONSTRAINT fk_order FOREIGN KEY(order_id) REFERENCES order(order_id)
                );
            </code>
            <img src="@controllers.routes.Assets.at("images/company_to_order.png")" style="padding-left: 5%" alt="" />
        </pre>
    </body>
</html>